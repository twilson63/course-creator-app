import { createReadStream, existsSync, statSync } from 'node:fs';
import { readFile } from 'node:fs/promises';
import { createServer } from 'node:http';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, '..');
const OUT_DIR = path.join(ROOT_DIR, 'out');
const PORT = Number(process.env.PORT || 4173);
const APP_SLUG = process.env.ONHYPER_APP_SLUG || 'course-creator-4473b404';
const HYPER_MICRO_TARGET = (process.env.HYPER_MICRO_TARGET || 'http://localhost:6363').replace(/\/$/, '');
const HYPER_MICRO_API_KEY = process.env.HYPER_MICRO_API_KEY || '';
const OPENAI_PROXY_MODE = process.env.OPENAI_PROXY_MODE || 'mock';
const OPENAI_BASE_URL = (process.env.OPENAI_BASE_URL || 'https://api.openai.com/v1').replace(/\/$/, '');
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || '';
const OPENROUTER_BASE_URL = (process.env.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1').replace(/\/$/, '');
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY || OPENAI_API_KEY;

const MIME_TYPES = {
  '.css': 'text/css; charset=utf-8',
  '.html': 'text/html; charset=utf-8',
  '.ico': 'image/x-icon',
  '.js': 'application/javascript; charset=utf-8',
  '.json': 'application/json; charset=utf-8',
  '.map': 'application/json; charset=utf-8',
  '.png': 'image/png',
  '.svg': 'image/svg+xml; charset=utf-8',
  '.txt': 'text/plain; charset=utf-8',
  '.webp': 'image/webp',
};

function getMimeType(filePath) {
  const extension = path.extname(filePath).toLowerCase();
  return MIME_TYPES[extension] || 'application/octet-stream';
}

function badRequest(res, statusCode, message) {
  res.writeHead(statusCode, { 'Content-Type': 'application/json; charset=utf-8' });
  res.end(JSON.stringify({ error: message }));
}

function buildProxyResponseHeaders(upstream, bodyLength) {
  const headers = {};
  upstream.headers.forEach((value, key) => {
    const lower = key.toLowerCase();
    if (lower === 'content-encoding' || lower === 'content-length' || lower === 'transfer-encoding' || lower === 'connection') {
      return;
    }
    headers[key] = value;
  });
  headers['content-length'] = String(bodyLength);
  return headers;
}

function validateAppSlug(req, res) {
  const slug = req.headers['x-app-slug'];

  if (!slug || typeof slug !== 'string') {
    badRequest(res, 401, 'Missing X-App-Slug header');
    return false;
  }

  if (slug !== APP_SLUG) {
    badRequest(res, 404, `Unknown app slug: ${slug}`);
    return false;
  }

  return true;
}

async function parseJsonBody(req) {
  const chunks = [];
  for await (const chunk of req) {
    chunks.push(chunk);
  }

  if (chunks.length === 0) {
    return {};
  }

  const raw = Buffer.concat(chunks).toString('utf8');
  return JSON.parse(raw);
}

function mockCourseJson() {
  return {
    meta: {
      title: 'Mock Course',
      description: 'Generated by local OnHyper mock.',
      difficulty: 'beginner',
      estimatedTime: '15 minutes',
    },
    steps: [
      {
        id: 'step-1',
        title: 'Introduction',
        content: 'Welcome to your local mocked AI response.',
        estimatedTime: '5 minutes',
      },
    ],
  };
}

async function handleOpenAiProxy(req, res, baseUrl = OPENAI_BASE_URL, apiKey = OPENAI_API_KEY) {
  if (!validateAppSlug(req, res)) {
    return;
  }

  if (req.method !== 'POST') {
    badRequest(res, 405, 'Method not allowed');
    return;
  }

  if (OPENAI_PROXY_MODE === 'passthrough') {
    if (!apiKey) {
      badRequest(res, 500, 'Missing API key for passthrough mode');
      return;
    }

    try {
      const chunks = [];
      for await (const chunk of req) {
        chunks.push(chunk);
      }
      const body = chunks.length > 0 ? Buffer.concat(chunks) : undefined;

      const upstream = await fetch(`${baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${apiKey}`,
          'Accept-Encoding': 'identity',
        },
        body,
      });

      const buffer = Buffer.from(await upstream.arrayBuffer());
      const responseHeaders = buildProxyResponseHeaders(upstream, buffer.length);

      res.writeHead(upstream.status, responseHeaders);
      res.end(buffer);
      return;
    } catch (error) {
      badRequest(res, 502, error instanceof Error ? error.message : 'OpenAI passthrough error');
      return;
    }
  }

  try {
    const payload = await parseJsonBody(req);
    const messages = Array.isArray(payload.messages) ? payload.messages : [];
    const systemContent = String(messages[0]?.content || '').toLowerCase();

    const content = systemContent.includes('html')
      ? '<!doctype html><html><body><h1>Local Mock Course</h1><p>Served by local OnHyper proxy.</p></body></html>'
      : JSON.stringify(mockCourseJson(), null, 2);

    const response = {
      id: `mock-${Date.now()}`,
      object: 'chat.completion',
      created: Math.floor(Date.now() / 1000),
      model: payload.model || 'gpt-4o-mini',
      choices: [
        {
          index: 0,
          finish_reason: 'stop',
          message: {
            role: 'assistant',
            content,
          },
        },
      ],
      usage: {
        prompt_tokens: 16,
        completion_tokens: 32,
        total_tokens: 48,
      },
    };

    res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
    res.end(JSON.stringify(response));
  } catch {
    badRequest(res, 400, 'Invalid JSON body');
  }
}

async function handleHyperMicroProxy(req, res, pathname) {
  if (!validateAppSlug(req, res)) {
    return;
  }

  const upstreamPath = pathname.replace(/^\/proxy\/(hyper-micro|hypermicro)/, '') || '/';
  const targetUrl = `${HYPER_MICRO_TARGET}${upstreamPath}${new URL(req.url, `http://${req.headers.host}`).search}`;

  try {
    const body = ['GET', 'HEAD'].includes(req.method || 'GET')
      ? undefined
      : await (async () => {
          const chunks = [];
          for await (const chunk of req) {
            chunks.push(chunk);
          }
          return chunks.length > 0 ? Buffer.concat(chunks) : undefined;
        })();

    const headers = { ...req.headers };
    delete headers.host;
    delete headers['x-app-slug'];

    if (HYPER_MICRO_API_KEY) {
      headers.authorization = `Bearer ${HYPER_MICRO_API_KEY}`;
    }

    headers['accept-encoding'] = 'identity';

    const upstream = await fetch(targetUrl, {
      method: req.method,
      headers,
      body,
    });

    const buffer = Buffer.from(await upstream.arrayBuffer());
    const responseHeaders = buildProxyResponseHeaders(upstream, buffer.length);

    res.writeHead(upstream.status, responseHeaders);
    res.end(buffer);
  } catch (error) {
    badRequest(res, 502, error instanceof Error ? error.message : 'Hyper-micro proxy error');
  }
}

function resolveStaticFile(requestPathname) {
  const decodedPath = decodeURIComponent(requestPathname);
  const normalized = decodedPath === '/' ? '/index.html' : decodedPath;
  const directPath = path.normalize(path.join(OUT_DIR, normalized));

  if (!directPath.startsWith(OUT_DIR)) {
    return null;
  }

  if (existsSync(directPath) && statSync(directPath).isFile()) {
    return directPath;
  }

  if (!path.extname(directPath)) {
    const htmlPath = `${directPath}.html`;
    if (existsSync(htmlPath) && statSync(htmlPath).isFile()) {
      return htmlPath;
    }

    const indexPath = path.join(directPath, 'index.html');
    if (existsSync(indexPath) && statSync(indexPath).isFile()) {
      return indexPath;
    }
  }

  return null;
}

async function handleStatic(req, res, pathname) {
  const filePath = resolveStaticFile(pathname);

  if (filePath) {
    res.writeHead(200, { 'Content-Type': getMimeType(filePath) });
    createReadStream(filePath).pipe(res);
    return;
  }

  const notFoundPath = path.join(OUT_DIR, '404.html');
  if (existsSync(notFoundPath)) {
    const html = await readFile(notFoundPath, 'utf8');
    res.writeHead(404, { 'Content-Type': 'text/html; charset=utf-8' });
    res.end(html);
    return;
  }

  badRequest(res, 404, 'Not found');
}

const server = createServer(async (req, res) => {
  const requestUrl = new URL(req.url || '/', `http://${req.headers.host}`);
  const { pathname } = requestUrl;
  const slugPrefix = `/a/${APP_SLUG}`;

  if (pathname === '/proxy/openai/v1/chat/completions') {
    await handleOpenAiProxy(req, res, OPENAI_BASE_URL, OPENAI_API_KEY);
    return;
  }

  if (pathname === '/proxy/openrouter/v1/chat/completions') {
    await handleOpenAiProxy(req, res, OPENROUTER_BASE_URL, OPENROUTER_API_KEY);
    return;
  }

  if (pathname.startsWith('/proxy/hyper-micro/') || pathname.startsWith('/proxy/hypermicro/')) {
    await handleHyperMicroProxy(req, res, pathname);
    return;
  }

  const staticPath = pathname === slugPrefix || pathname.startsWith(`${slugPrefix}/`)
    ? pathname.slice(slugPrefix.length) || '/'
    : pathname;

  await handleStatic(req, res, staticPath);
});

if (!existsSync(OUT_DIR)) {
  console.error('Missing static output directory. Run `npm run build` first.');
  process.exit(1);
}

server.listen(PORT, () => {
  console.log(`Local OnHyper server running at http://localhost:${PORT}`);
  console.log(`Expected X-App-Slug: ${APP_SLUG}`);
  console.log(`Hyper-micro target: ${HYPER_MICRO_TARGET}`);
  console.log(`Hyper-micro auth: ${HYPER_MICRO_API_KEY ? 'enabled' : 'disabled'}`);
  console.log(`OpenAI proxy mode: ${OPENAI_PROXY_MODE}`);
  if (OPENAI_PROXY_MODE === 'passthrough') {
    console.log(`OpenAI base URL: ${OPENAI_BASE_URL}`);
    console.log(`OpenAI auth: ${OPENAI_API_KEY ? 'enabled' : 'disabled'}`);
  }
});
